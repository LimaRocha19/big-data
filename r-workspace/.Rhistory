created = list(
"$gte" = list(
"$date" = list("$numberLong" = paste0(as.integer(anytime::anytime(from)),'000'))
),
"$lte" = list(
"$date" = list("$numberLong" = paste0(as.integer(anytime::anytime(to)),'000'))
)
)
)
query_json <- toJSON(query, auto_unbox = TRUE, pretty = TRUE)
result <- db$find(query_json)
result <- unnest(result)
# result <- result %>% mutate(stamps = paste0(as.integer(anytime::anytime(created)),'000')) %>% select(watts, stamps)
return(result)
}
# como trataremos como uma série temporal, é necessário tratar irregularidades
# para resolver possíveis irregularidades, adicionaremos as lacunas de tempo que foram 'puladas' como valores vazios
missing_stamps <- function (data, from, to) {
# converting to unix time
begin <- paste0(as.integer(anytime::anytime(from)),'000')
endin <- paste0(as.integer(anytime::anytime(to)),'000')
stamps <- seq(begin, endin, 4) # step de 4s é o mais observado nas análises
times <- data.frame(stamps)
result <- merge(data, times, by = c('stamps'))
return(result)
}
consumption <- query_date('2020-04-16', '2020-04-17')
library(tidyverse)
library(mongolite)
library(jsonlite)
library(anytime)
library(astsa, quietly=TRUE, warn.conflicts=FALSE)
library(knitr)
library(printr)
library(lubridate)
library(gridExtra)
library(reshape2)
library(TTR)
library(tseries)
library(mgcv)
# conectando ao banco
db <- mongo('logs', url = 'mongodb+srv://lima:st10900152@cluster0-6zng5.gcp.mongodb.net/test?retryWrites=true&w=majority')
# realiza a query e retorna os dados com tempos em unixtime
query_date <- function(from, to) {
query <- list(
created = list(
"$gte" = list(
"$date" = list("$numberLong" = paste0(as.integer(anytime::anytime(from)),'000'))
),
"$lte" = list(
"$date" = list("$numberLong" = paste0(as.integer(anytime::anytime(to)),'000'))
)
)
)
query_json <- toJSON(query, auto_unbox = TRUE, pretty = TRUE)
result <- db$find(query_json)
result <- unnest(result)
result <- result %>% mutate(stamps = paste0(as.integer(anytime::anytime(created)),'000')) %>% select(watts, stamps)
return(result)
}
# como trataremos como uma série temporal, é necessário tratar irregularidades
# para resolver possíveis irregularidades, adicionaremos as lacunas de tempo que foram 'puladas' como valores vazios
missing_stamps <- function (data, from, to) {
# converting to unix time
begin <- paste0(as.integer(anytime::anytime(from)),'000')
endin <- paste0(as.integer(anytime::anytime(to)),'000')
stamps <- seq(begin, endin, 4) # step de 4s é o mais observado nas análises
times <- data.frame(stamps)
result <- merge(data, times, by = c('stamps'))
return(result)
}
consumption <- query_date('2020-04-16', '2020-04-17')
library(tidyverse)
library(mongolite)
library(jsonlite)
library(anytime)
library(astsa, quietly=TRUE, warn.conflicts=FALSE)
library(knitr)
library(printr)
library(lubridate)
library(gridExtra)
library(reshape2)
library(TTR)
library(tseries)
library(mgcv)
# conectando ao banco
db <- mongo('logs', url = 'mongodb+srv://lima:st10900152@cluster0-6zng5.gcp.mongodb.net/test?retryWrites=true&w=majority')
# realiza a query e retorna os dados com tempos em unixtime
query_date <- function(from, to) {
query <- list(
created = list(
"$gte" = list(
"$date" = list("$numberLong" = paste0(as.integer(anytime::anytime(from)),'000'))
),
"$lte" = list(
"$date" = list("$numberLong" = paste0(as.integer(anytime::anytime(to)),'000'))
)
)
)
query_json <- toJSON(query, auto_unbox = TRUE, pretty = TRUE)
result <- db$find(query_json)
result <- as.tibble(result)
result <- result %>% mutate(stamps = paste0(as.integer(anytime::anytime(created)),'000')) %>% select(watts, stamps)
return(result)
}
# como trataremos como uma série temporal, é necessário tratar irregularidades
# para resolver possíveis irregularidades, adicionaremos as lacunas de tempo que foram 'puladas' como valores vazios
missing_stamps <- function (data, from, to) {
# converting to unix time
begin <- paste0(as.integer(anytime::anytime(from)),'000')
endin <- paste0(as.integer(anytime::anytime(to)),'000')
stamps <- seq(begin, endin, 4) # step de 4s é o mais observado nas análises
times <- data.frame(stamps)
result <- merge(data, times, by = c('stamps'))
return(result)
}
consumption <- query_date('2020-04-16', '2020-04-17')
library(tidyverse)
library(mongolite)
library(jsonlite)
library(anytime)
library(astsa, quietly=TRUE, warn.conflicts=FALSE)
library(knitr)
library(printr)
library(lubridate)
library(gridExtra)
library(reshape2)
library(TTR)
library(tseries)
library(mgcv)
# conectando ao banco
db <- mongo('logs', url = 'mongodb+srv://lima:st10900152@cluster0-6zng5.gcp.mongodb.net/test?retryWrites=true&w=majority')
# realiza a query e retorna os dados com tempos em unixtime
query_date <- function(from, to) {
query <- list(
created = list(
"$gte" = list(
"$date" = list("$numberLong" = paste0(as.integer(anytime::anytime(from)),'000'))
),
"$lte" = list(
"$date" = list("$numberLong" = paste0(as.integer(anytime::anytime(to)),'000'))
)
)
)
query_json <- toJSON(query, auto_unbox = TRUE, pretty = TRUE)
result <- db$find(query_json)
result <- as_tibble(result)
result <- result %>% mutate(stamps = paste0(as.integer(anytime::anytime(created)),'000')) %>% select(watts, stamps)
return(result)
}
# como trataremos como uma série temporal, é necessário tratar irregularidades
# para resolver possíveis irregularidades, adicionaremos as lacunas de tempo que foram 'puladas' como valores vazios
missing_stamps <- function (data, from, to) {
# converting to unix time
begin <- paste0(as.integer(anytime::anytime(from)),'000')
endin <- paste0(as.integer(anytime::anytime(to)),'000')
stamps <- seq(begin, endin, 4) # step de 4s é o mais observado nas análises
times <- data.frame(stamps)
result <- merge(data, times, by = c('stamps'))
return(result)
}
consumption <- query_date('2020-04-16', '2020-04-17')
consumption
library(tidyverse)
library(mongolite)
library(jsonlite)
library(anytime)
library(astsa, quietly=TRUE, warn.conflicts=FALSE)
library(knitr)
library(printr)
library(lubridate)
library(gridExtra)
library(reshape2)
library(TTR)
library(tseries)
library(mgcv)
# conectando ao banco
db <- mongo('logs', url = 'mongodb+srv://lima:st10900152@cluster0-6zng5.gcp.mongodb.net/test?retryWrites=true&w=majority')
# realiza a query e retorna os dados com tempos em unixtime
query_date <- function(from, to) {
query <- list(
created = list(
"$gte" = list(
"$date" = list("$numberLong" = paste0(as.integer(anytime::anytime(from)),'000'))
),
"$lte" = list(
"$date" = list("$numberLong" = paste0(as.integer(anytime::anytime(to)),'000'))
)
)
)
query_json <- toJSON(query, auto_unbox = TRUE, pretty = TRUE)
result <- db$find(query_json)
result <- as_tibble(result)
result <- result %>% mutate(stamps = paste0(as.integer(anytime::anytime(created)),'')) %>% select(watts, stamps)
return(result)
}
# como trataremos como uma série temporal, é necessário tratar irregularidades
# para resolver possíveis irregularidades, adicionaremos as lacunas de tempo que foram 'puladas' como valores vazios
missing_stamps <- function (data, from, to) {
# converting to unix time
begin <- paste0(as.integer(anytime::anytime(from)),'000')
endin <- paste0(as.integer(anytime::anytime(to)),'000')
stamps <- seq(begin, endin, 4) # step de 4s é o mais observado nas análises
times <- data.frame(stamps)
result <- merge(data, times, by = c('stamps'))
return(result)
}
consumption <- query_date('2020-04-16', '2020-04-17')
consumption
missing_stamps(consumption, '2020-04-16', '2020-04-17')
stamps <- missing_stamps(consumption, '2020-04-16', '2020-04-17')
stamps <- missing_stamps(consumption, '2020-04-16', '2020-04-17')
library(tidyverse)
library(mongolite)
library(jsonlite)
library(anytime)
library(astsa, quietly=TRUE, warn.conflicts=FALSE)
library(knitr)
library(printr)
library(lubridate)
library(gridExtra)
library(reshape2)
library(TTR)
library(tseries)
library(mgcv)
# conectando ao banco
db <- mongo('logs', url = 'mongodb+srv://lima:st10900152@cluster0-6zng5.gcp.mongodb.net/test?retryWrites=true&w=majority')
# realiza a query e retorna os dados com tempos em unixtime
query_date <- function(from, to) {
query <- list(
created = list(
"$gte" = list(
"$date" = list("$numberLong" = paste0(as.integer(anytime::anytime(from)),'000'))
),
"$lte" = list(
"$date" = list("$numberLong" = paste0(as.integer(anytime::anytime(to)),'000'))
)
)
)
query_json <- toJSON(query, auto_unbox = TRUE, pretty = TRUE)
result <- db$find(query_json)
result <- as_tibble(result)
result <- result %>% mutate(stamps = paste0(as.integer(anytime::anytime(created)),'')) %>% select(watts, stamps)
return(result)
}
# como trataremos como uma série temporal, é necessário tratar irregularidades
# para resolver possíveis irregularidades, adicionaremos as lacunas de tempo que foram 'puladas' como valores vazios
missing_stamps <- function (data, from, to) {
# converting to unix time
begin <- paste0(as.integer(anytime::anytime(from)),'')
endin <- paste0(as.integer(anytime::anytime(to)),'')
stamps <- seq(begin, endin, 4) # step de 4s é o mais observado nas análises
print(stamps)
times <- data.frame(stamps)
result <- merge(data, times, by = c('stamps'))
return(result)
}
missing_stamps <- function (data, from, to) {
# converting to unix time
begin <- paste0(as.integer(anytime::anytime(from)),'')
endin <- paste0(as.integer(anytime::anytime(to)),'')
stamps <- seq(begin, endin, 4) # step de 4s é o mais observado nas análises
times <- data.frame(stamps)
print(times)
result <- merge(data, times, by = c('stamps'))
return(result)
}
stamps <- missing_stamps(consumption, '2020-04-16', '2020-04-17')
stamps <- missing_stamps(consumption, '2020-04-16', '2020-04-17')
stamps
consumption <- query_date('2020-04-16 10:00:00', '2020-04-16 12:00:00')
stamps <- missing_stamps(consumption, '2020-04-16 10:00:00', '2020-04-16 12:00:00')
missing_stamps <- function (data, from, to) {
# converting to unix time
begin <- paste0(as.integer(anytime::anytime(from)),'')
endin <- paste0(as.integer(anytime::anytime(to)),'')
stamps <- seq(begin, endin, 4) # step de 4s é o mais observado nas análises
times <- data.frame(stamps)
# print(times)
result <- merge(data, times, by = c('stamps'))
return(result)
}
stamps <- missing_stamps(consumption, '2020-04-16 10:00:00', '2020-04-16 12:00:00')
View(consumption)
View(stamps)
missing_stamps <- function (data) {
n <- nrow(data)
# converting to unix time
begin <- paste0(as.integer(anytime::anytime(data$stamps(1))),'')
endin <- paste0(as.integer(anytime::anytime(data$stamps(n))),'')
stamps <- seq(begin, endin, 4) # step de 4s é o mais observado nas análises
times <- data.frame(stamps)
# print(times)
result <- merge(data, times, by = c('stamps'))
return(result)
}
stamps <- missing_stamps(consumption)
consumption$stamps
consumption$stamps(1)
missing_stamps <- function (data) {
n <- nrow(data)
# converting to unix time
begin <- paste0(as.integer(anytime::anytime(data$stamps[1])),'')
endin <- paste0(as.integer(anytime::anytime(data$stamps[n])),'')
stamps <- seq(begin, endin, 4) # step de 4s é o mais observado nas análises
times <- data.frame(stamps)
# print(times)
result <- merge(data, times, by = c('stamps'))
return(result)
}
stamps <- missing_stamps(consumption)
paste0(as.integer(anytime::anytime(consumption$stamps[1])),'')
consumption$stamps[1]
missing_stamps <- function (data) {
n <- nrow(data)
# converting to unix time
begin <- data$stamps[1]
endin <- data$stamps[n]
stamps <- seq(begin, endin, 4) # step de 4s é o mais observado nas análises
times <- data.frame(stamps)
# print(times)
result <- merge(data, times, by = c('stamps'))
return(result)
}
stamps <- missing_stamps(consumption)
View(stamps)
View(consumption)
consumption <- query_date('2020-04-16', '2020-05-11')
?SMA
seq(1, 10)
?CJ
library(tidyverse)
library(mongolite)
library(jsonlite)
library(anytime)
library(astsa, quietly=TRUE, warn.conflicts=FALSE)
library(knitr)
library(printr)
library(lubridate)
library(gridExtra)
library(reshape2)
library(TTR)
library(tseries)
library(mgcv)
# conectando ao banco
db <- mongo('logs', url = 'mongodb+srv://lima:st10900152@cluster0-6zng5.gcp.mongodb.net/test?retryWrites=true&w=majority')
# realiza a query e retorna os dados com tempos em unixtime
query_date <- function(from, to) {
query <- list(
created = list(
"$gte" = list(
"$date" = list("$numberLong" = paste0(as.integer(anytime::anytime(from)),'000'))
),
"$lte" = list(
"$date" = list("$numberLong" = paste0(as.integer(anytime::anytime(to)),'000'))
)
)
)
query_json <- toJSON(query, auto_unbox = TRUE, pretty = TRUE)
result <- db$find(query_json)
result <- as_tibble(result)
result <- result %>% mutate(stamps = paste0(as.integer(anytime::anytime(created)),'')) %>% select(watts, stamps)
return(result)
}
# como trataremos como uma série temporal, é necessário tratar irregularidades
# para resolver possíveis irregularidades, adicionaremos as lacunas de tempo que foram 'puladas' como valores vazios
missing_stamps <- function (data) {
n <- nrow(data)
# converting to unix time
begin <- data$stamps[1]
endin <- data$stamps[n]
stamps <- seq(begin, endin, 4) # step de 4s é o mais observado nas análises
times <- data.frame(stamps)
# print(times)
result <- merge(data, times)
return(result)
}
consumption <- query_date('2020-04-16', '2020-04-17')
stamps <- missing_stamps(consumption)
?left_join
missing_stamps <- function (data) {
n <- nrow(data)
# converting to unix time
begin <- data$stamps[1]
endin <- data$stamps[n]
stamps <- seq(begin, endin, 4) # step de 4s é o mais observado nas análises
times <- data.frame(stamps)
# print(times)
result <- left_join(data, times)
return(result)
}
stamps <- missing_stamps(consumption)
missing_stamps <- function (data) {
n <- nrow(data)
# converting to unix time
begin <- data$stamps[1]
endin <- data$stamps[n]
stamps <- seq(begin, endin, 4) # step de 4s é o mais observado nas análises
times <- data.frame(stamps)
# print(times)
result <- left_join(times, data)
return(result)
}
stamps <- missing_stamps(consumption)
consumption
library(tidyverse)
library(mongolite)
library(jsonlite)
library(anytime)
library(astsa, quietly=TRUE, warn.conflicts=FALSE)
library(knitr)
library(printr)
library(lubridate)
library(gridExtra)
library(reshape2)
library(TTR)
library(tseries)
library(mgcv)
# conectando ao banco
db <- mongo('logs', url = 'mongodb+srv://lima:st10900152@cluster0-6zng5.gcp.mongodb.net/test?retryWrites=true&w=majority')
# realiza a query e retorna os dados com tempos em unixtime
query_date <- function(from, to) {
query <- list(
created = list(
"$gte" = list(
"$date" = list("$numberLong" = paste0(as.integer(anytime::anytime(from)),'000'))
),
"$lte" = list(
"$date" = list("$numberLong" = paste0(as.integer(anytime::anytime(to)),'000'))
)
)
)
query_json <- toJSON(query, auto_unbox = TRUE, pretty = TRUE)
result <- db$find(query_json)
result <- as_tibble(result)
result <- result %>% mutate(stamps = as.numeric(paste0(as.integer(anytime::anytime(created))),'')) %>% select(watts, stamps)
return(result)
}
# como trataremos como uma série temporal, é necessário tratar irregularidades
# para resolver possíveis irregularidades, adicionaremos as lacunas de tempo que foram 'puladas' como valores vazios
missing_stamps <- function (data) {
n <- nrow(data)
# converting to unix time
begin <- data$stamps[1]
endin <- data$stamps[n]
stamps <- seq(begin, endin, 4) # step de 4s é o mais observado nas análises
times <- data.frame(stamps)
# print(times)
result <- left_join(times, data)
return(result)
}
consumption <- query_date('2020-04-16', '2020-04-17')
stamps <- missing_stamps(consumption)
stamps
missing_stamps <- function (data) {
n <- nrow(data)
# converting to unix time
begin <- data$stamps[1]
endin <- data$stamps[n]
stamps <- seq(begin, endin, 1) # step de 4s é o mais observado nas análises
times <- data.frame(stamps)
# print(times)
result <- left_join(times, data)
return(result)
}
stamps <- missing_stamps(consumption)
stamps
ts(stamps, deltat = 1)
series <- ts(stamps, deltat = 1)
plot.ts(series)
series <- ts(stamps$watts, deltat = 1)
plot.ts(series)
ggplot(data = stamps, mapping = aes(x = stamps, y = watts)) + geom_line()
ggplot(data = consumption, mapping = aes(x = stamps, y = watts)) + geom_line()
na\_mean(stamps)
na_mean(stamps)
install.packages('imputeTS')
library(imputeTS)
na_mean(stamps)
missing_stamps <- function (data) {
n <- nrow(data)
# converting to unix time
begin <- data$stamps[1]
endin <- data$stamps[n]
stamps <- seq(begin, endin, 1) # step de 4s é o mais observado nas análises
times <- data.frame(stamps)
# print(times)
result <- left_join(times, data)
result <- na_mean(result)
return(result)
}
stamps <- missing_stamps(consumption)
ggplot(data = stamps, mapping = aes(x = stamps, y = watts)) + geom_line()
missing_stamps <- function (data) {
n <- nrow(data)
# converting to unix time
begin <- data$stamps[1]
endin <- data$stamps[n]
stamps <- seq(begin, endin, 1) # step de 4s é o mais observado nas análises
times <- data.frame(stamps)
# print(times)
result <- left_join(times, data)
result <- na_interpolation(result)
return(result)
}
stamps <- missing_stamps(consumption)
ggplot(data = stamps, mapping = aes(x = stamps, y = watts)) + geom_line()
ggplot(data = stamps, mapping = aes(x = stamps, y = watts)) + geom_point()
consumption <- query_date('2020-04-30', '2020-05-02')
stamps <- missing_stamps(consumption)
ggplot(data = stamps, mapping = aes(x = stamps, y = watts)) + geom_point()
?SMA
